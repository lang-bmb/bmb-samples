// Invariants - Loop invariant patterns with contracts
// Demonstrates maintaining properties through iterations

// Binary search with invariant: target always in [low, high] if present
fn binary_search_iter(arr_start: i64, arr_end: i64, target: i64, low: i64, high: i64) -> i64
  pre low >= arr_start
  pre high <= arr_end
=
    if low > high { 0 - 1  // Not found } else { let mid = low + (high - low) / 2 };
         let mid_val = get_sorted_value(mid);  // Simulated array access
         if mid_val == target { mid } else if mid_val < target { binary_search_iter(arr_start, arr_end, target, mid + 1, high) } else { binary_search_iter(arr_start, arr_end, target, low, mid - 1) };

// Simulated sorted array: returns index * 2 (0, 2, 4, 6, ...)
fn get_sorted_value(index: i64) -> i64 = index * 2;

fn binary_search(size: i64, target: i64) -> i64
  pre size > 0
= binary_search_iter(0, size - 1, target, 0, size - 1);

// GCD with invariant: gcd(a, b) == gcd(original_a, original_b)
fn gcd_iter(a: i64, b: i64) -> i64
  pre a >= 0
  pre b >= 0
  post ret >= 0
=
    if b == 0 { a } else { gcd_iter(b, a - (a / b) * b) };

fn gcd(a: i64, b: i64) -> i64
  pre a >= 0 and b >= 0
  post ret >= 0
= gcd_iter(a, b);

// Sum with running total invariant: acc == sum of processed elements
fn sum_with_invariant_iter(n: i64, current: i64, acc: i64) -> i64
  pre current >= 1
  pre acc >= 0
  // Invariant: acc == sum(1..current-1)
  post ret == n * (n + 1) / 2
=
    if current > n { acc } else { sum_with_invariant_iter(n, current + 1, acc + current) };

fn sum_1_to_n(n: i64) -> i64
  pre n >= 0
  post ret == n * (n + 1) / 2
= if n == 0 { 0 } else { sum_with_invariant_iter(n, 1, 0) };

// Factorial with invariant: acc == factorial(current - 1)
fn factorial_iter(n: i64, current: i64, acc: i64) -> i64
  pre current >= 1
  pre acc >= 1
  post ret >= 1
=
    if current > n { acc } else { factorial_iter(n, current + 1, acc * current) };

fn factorial(n: i64) -> i64
  pre n >= 0
  post ret >= 1
= if n == 0 { 1 } else { factorial_iter(n, 1, 1) };

// Power with invariant: result * base^remaining == base^original_exp
fn power_with_invariant_iter(base: i64, remaining: i64, result: i64) -> i64
  pre remaining >= 0
  pre result >= 1
=
    if remaining == 0 { result } else { power_with_invariant_iter(base, remaining - 1, result * base) };

fn power(base: i64, exp: i64) -> i64
  pre exp >= 0
= power_with_invariant_iter(base, exp, 1);

fn main() -> i64 = {
    // Binary search for value 6 in array [0,2,4,6,8,10]
    let u0 = println(binary_search(6, 6));  // 3 (index)

    // GCD
    let u1 = println(gcd(48, 18));  // 6

    // Sum 1 to 10
    let u2 = println(sum_1_to_n(10));  // 55

    // Factorial 5
    let u3 = println(factorial(5));  // 120

    // Power 2^10
    let u4 = println(power(2, 10));  // 1024

    0
};
