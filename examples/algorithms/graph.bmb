-- Graph Algorithms - Basic graph operations
-- Encoded using adjacency information patterns

-- Graph representation: edges encoded as pairs
-- For simplicity, we use a fixed small graph

-- Example graph (5 nodes, 6 edges):
-- 0 -- 1 -- 2
-- |    |    |
-- 3 -- 4 ----+

-- Check if edge exists (hardcoded adjacency)
fn has_edge(from: i64, to: i64) -> bool =
    (from == 0 and to == 1) or (from == 1 and to == 0) or
    (from == 1 and to == 2) or (from == 2 and to == 1) or
    (from == 0 and to == 3) or (from == 3 and to == 0) or
    (from == 1 and to == 4) or (from == 4 and to == 1) or
    (from == 3 and to == 4) or (from == 4 and to == 3) or
    (from == 2 and to == 4) or (from == 4 and to == 2);

-- Count edges for a node (degree)
fn degree_iter(node: i64, check: i64, count: i64, max_node: i64) -> i64 =
    if check > max_node then count
    else let inc = if has_edge(node, check) then 1 else 0;
         degree_iter(node, check + 1, count + inc, max_node);

fn degree(node: i64) -> i64
  pre node >= 0 and node <= 4
= degree_iter(node, 0, 0, 4);

-- Check path exists (BFS-like using visited flags encoded as bits)
fn can_reach_iter(start: i64, target: i64, visited: i64, max_node: i64) -> bool =
    if start == target then true
    else if is_visited(start, visited) then false
    else let new_visited = mark_visited(start, visited);
         try_neighbors(start, target, new_visited, 0, max_node);

fn try_neighbors(current: i64, target: i64, visited: i64, neighbor: i64, max_node: i64) -> bool =
    if neighbor > max_node then false
    else if has_edge(current, neighbor) and can_reach_iter(neighbor, target, visited, max_node) then true
    else try_neighbors(current, target, visited, neighbor + 1, max_node);

fn is_visited(node: i64, visited: i64) -> bool =
    let mask = power_of_2(node);
    (visited / mask) - ((visited / mask) / 2) * 2 == 1;

fn mark_visited(node: i64, visited: i64) -> i64 =
    visited + power_of_2(node);

fn power_of_2(n: i64) -> i64 =
    if n <= 0 then 1
    else 2 * power_of_2(n - 1);

fn can_reach(start: i64, target: i64) -> bool
  pre start >= 0 and start <= 4
  pre target >= 0 and target <= 4
= can_reach_iter(start, target, 0, 4);

-- Count total edges in graph
fn count_edges_iter(from: i64, to: i64, count: i64, max: i64) -> i64 =
    if from > max then count / 2  -- Each edge counted twice
    else if to > max then count_edges_iter(from + 1, 0, count, max)
    else let inc = if has_edge(from, to) then 1 else 0;
         count_edges_iter(from, to + 1, count + inc, max);

fn count_edges() -> i64 = count_edges_iter(0, 0, 0, 4);

-- Check if graph is connected (all nodes reachable from 0)
fn is_connected_iter(node: i64, max: i64) -> bool =
    if node > max then true
    else if not can_reach(0, node) then false
    else is_connected_iter(node + 1, max);

fn is_connected() -> bool = is_connected_iter(0, 4);

fn main() -> i64 = {
    -- Degrees: node 1 has degree 3, node 0 has degree 2
    let u0 = println(degree(1));  -- 3
    let u1 = println(degree(0));  -- 2

    -- Reachability: 0 can reach 2
    let u2 = println(if can_reach(0, 2) then 1 else 0);  -- 1

    -- Total edges
    let u3 = println(count_edges());  -- 6

    -- Graph is connected
    let u4 = println(if is_connected() then 1 else 0);  -- 1

    0
};
