// Loops - Iteration patterns using recursion
// BMB uses tail recursion instead of imperative loops

// Sum from 1 to n (like for i = 1 to n)
fn sum_to_iter(n: i64, acc: i64) -> i64 =
    if n <= 0 { acc } else { sum_to_iter(n - 1, acc + n) };

fn sum_to(n: i64) -> i64
  pre n >= 0
  post ret == n * (n + 1) / 2
= sum_to_iter(n, 0);

// Count down (like while n > 0)
fn countdown_iter(n: i64, steps: i64) -> i64 =
    if n <= 0 { steps } else { countdown_iter(n - 1, steps + 1) };

fn countdown(n: i64) -> i64
  pre n >= 0
  post ret == n
= countdown_iter(n, 0);

// Repeat action n times
fn repeat_iter(n: i64, value: i64, acc: i64) -> i64 =
    if n <= 0 { acc } else { repeat_iter(n - 1, value, acc + value) };

fn repeat_add(n: i64, value: i64) -> i64
  pre n >= 0
  post ret == n * value
= repeat_iter(n, value, 0);

// Find first matching (like break in loop)
fn find_first_divisible_iter(start: i64, limit: i64, divisor: i64) -> i64 =
    if start > limit { 0 - 1  // Not found, return -1 } else if start - (start / divisor) * divisor == 0 { start } else { find_first_divisible_iter(start + 1, limit, divisor) };

fn find_first_divisible(start: i64, limit: i64, divisor: i64) -> i64
  pre divisor != 0
= find_first_divisible_iter(start, limit, divisor);

// Nested loop pattern: sum of products
fn inner_loop(i: i64, j: i64, limit: i64, acc: i64) -> i64 =
    if j > limit { acc } else { inner_loop(i, j + 1, limit, acc + i * j) };

fn outer_loop(i: i64, limit: i64, acc: i64) -> i64 =
    if i > limit { acc } else { outer_loop(i + 1, limit, inner_loop(i, 1, limit, acc)) };

fn sum_of_products(n: i64) -> i64
  pre n >= 0
= outer_loop(1, n, 0);

fn main() -> i64 = {
    let u0 = println(sum_to(10));           // 55
    let u1 = println(countdown(5));          // 5
    let u2 = println(repeat_add(4, 7));      // 28

    let first_div = find_first_divisible(10, 20, 3);
    let u3 = println(first_div);             // 12

    let u4 = println(sum_of_products(3));    // 1*1+1*2+1*3+2*1+2*2+2*3+3*1+3*2+3*3 = 36

    0
};
